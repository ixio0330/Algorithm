# 정렬 알고리즘

버블 정렬 알고리즘을 설명하기에 앞서, 정렬 알고리즘에 대해 소개하겠습니다.

정렬은 프로그래밍에서 정말로 흔하게 사용됩니다. 

물론 각 언어마다 제공하는 method들이 존재하지만, 만약 대부분의 요소들이 정렬되어 있고 아주 소수의 요소들만 정렬하면 될 때 직접 구현해서 사용할 수도 있습니다.

각 알고리즘마다 두각을 나타내는 특징이 있기 때문입니다.

**기본 정렬 알고리즘**

- 버블 정렬
- 선택 정렬
- 삽입 정렬

위의 정렬 알고리즘들은 효율성이 떨어져서 흔히 사용되지는 않지만, 알아둘 필요가 있습니다.

먼저 버블 정렬부터 알아보겠습니다.

# 버블 정렬 (Bubble sort)

버블 정렬은 배열을 오름차순으로 정렬하려고 할 때, 더 큰 숫자를 한번에 하나씩 뒤로 이동시키면서 정렬하는 알고리즘입니다.

버블 정렬을 사용한 함수를 만들기 전에, 입력값을 생각해보고 버블 정렬이 진행되는 과정과 출력값을 생각해봅시다.

**입력값**

```
bubbleSort([37, 45, 29, 8]);
```

**과정**

1. [37, 29, 45, 8]
2. [37, 29, 8, 45]
3. [29, 37, 8, 45]
4. [29, 8, 37, 45]
5. [8, 27, 37, 45]

**출력값**

```
[8, 27, 37, 45]
```

## 버블 정렬 구현

반복문을 0부터 배열의 길이만큼 실행시키는건 정말 비효율적입니다. 

버블 정렬은 앞 뒤 요소를 계속해서 비교해서 이동시키기 때문에, 결국 배열에서 가장 큰 요소는 항상 뒤에 위치하게 됩니다. 

이미 정렬된 요소는 제외하고 정렬을 하는게 더 효율적이겠죠?

설명이 부족해서 이해가 되지 않는다면 원하는 배열을 넣고 아래 함수를 실행시켜보세요!

```
function bubbleSort(arr) {
  for (let i = arr.length; i > 0; i--) {
    console.log(`------------------------`);
    for (let j = 0; j < i - 1; j++) {
      console.log(`${arr} | ${arr[j]} vs ${arr[j + 1]}`);
      if (arr[j] > arr[j + 1]) {
        let temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
  return arr;
}
```

버블 정렬을 사용해서 [37, 45, 29, 8]를 정렬해 봅시다. 위 코드를 실행시키면 버블 정렬의 과정을 볼 수 있습니다.

```
------------------------
37,45,29,8 | 37 vs 45
37,45,29,8 | 45 vs 29
37,29,45,8 | 45 vs 8
------------------------
37,29,8,45 | 37 vs 29 // 1의 결과
29,37,8,45 | 37 vs 8
------------------------
29,8,37,45 | 29 vs 8 // 2의 결과
------------------------
```

1. 첫 번째 반복문이 실행 되면 45가 가장 마지막에 위치합니다.
2. 두 번째 반복문이 실행 되면 37, 45가 마지막에 위치합니다.

결과는 [ 8, 29, 37, 45 ]로 잘 나오네요.

만약 현재 버블 정렬 함수에 [8, 1, 2, 3, 4, 5, 6, 7] 배열을 넣게 되면 어떻게 될까요?

총 8 X N 번의 연산을 합니다. 이미 정렬되어 있는 배열을 정렬할 때는 버블 정렬이 매우 효율적이지 않네요.

그렇지만 버블 정렬을 조금만 수정하면 이미 정렬되어 있는 배열도 적은 연산으로 정렬할 수 있습니다.

## 버블 정렬 최적화

배열의 요소를 바꾸지 않았을 경우 반복문을 빠져나오는 버블 정렬 함수입니다.

버블 정렬 과정을 보고싶다면 원하는 배열을 넣고 아래 함수를 실행시켜보세요!

```
function bubbleSort(arr) {
  let noSwaps;

  for (let i = arr.length; i > 0; i--) {
    noSwaps = true;
    console.log('-----------------------------------');
    for (let j = 0; j < i - 1; j++) {
      console.log(`${arr} | ${arr[j]} vs ${arr[j + 1]}`);
      if (arr[j] > arr[j + 1]) {
        let temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
        noSwaps = false;
      }
    }
    if (noSwaps) break;
  }
  return arr;
}
```

너무나 당연한 얘기같죠. 배열의 요소를 바꾸지 않았다는건 배열이 정렬되어 있다는 의미니까요.

사람은 [8, 1, 2, 3, 4, 5, 6, 7]을 보자마자 이미 잘 정렬되어 있는 배열이라는 것을 알 수 있습니다.

또한 8이 맨 뒤로 가면 완벽하게 정리된 배열을 만들 수 있다는 것도 압니다. 

하지만 컴퓨터는 그렇지 않습니다. :)...

### Swap 함수

배열의 요소를 변경하는 일이 잦다면 배열은 참조형이라는 점을 활용해서 swap 함수를 따로 선언해서 사용할 수도 있습니다.

JavaScript를 사용하면 두 가지 방법이 있습니다. 편한 방법을 사용하면 됩니다.

**(1)**

```
function swap1(arr, idx1, idx2) {
  let temp = arr[idx1];
  add[idx1] = arr[idx2];
  arr[idx2] = temp;
}
```

**(2)**

```
function swap2(arr, idx1, idx2) {
  [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];
}
```
